import java.io.FileWriter;
import java.util.ArrayList;

public class Ln {
    ArrayList<Double> naiveValues; //generated using taylor
    ArrayList<Double> smartValues; //generated by multiplying last value
    protected double N;
    private double x;
    private double trueLn;

    //szereg McLaurina przewiduje dokładność dla wartości -1<x<=1 dla ln=(1+x)
    // wyraz to (((-1)^(n+1))/n) * x^n

    public Ln(int N, double x) {
        this.N = N;
        this.x = x;
        trueLn = java.lang.Math.log(x);
        naiveValues = fillArrayNaive();
        smartValues = fillArraySmart();
    }

    public double getTrueLn() {
        return trueLn;
    }

    // oryginalny logarytm
    // java.lang.Math.log(double a)
    private ArrayList<Double> fillArrayNaive(){
        double x = this.x-1.0d;
        ArrayList<Double> naiveValues = new ArrayList<>();
        for(double n=1.0d; n<=N; n++){
            //naiveValues.add((MyMath.pow((-1.0d),(n+1.0d))/n) * MyMath.pow(x, n));
            naiveValues.add((MyMath.powForMinusOne(n+1.0d)/n) * MyMath.pow(x, n));
        }
        return naiveValues;
    }

    private ArrayList<Double> fillArraySmart(){
        double x = this.x-1;
        ArrayList<Double> smartValues = new ArrayList<>();
        double tempValue = x;
        for(double n=1; n<=N; n++){
            //różnica między kolejnymi wyrazami to -nx/(n+1)
            smartValues.add(tempValue);
            tempValue *= (-n*x/(n+1.0));
        }
        return smartValues;
    }

    public double getSum(ArrayList<Double> values){
        double sum = 0;
        for ( double value : values ) {
            sum += value;
        }
        return sum;
    }

    public double getReverseCountedSum(ArrayList<Double> values){
        double sum = 0;
        for(int i = values.size(); i>0; i--){
            sum += values.get(i-1);
        }
        return sum;
    }

    public double getRelativeError(double x){
        return (Math.abs(this.trueLn - x)/this.trueLn);
    }

    static GraphDataStorage createGraph(int startP, int endP, double x){
        GraphDataStorage gds = new GraphDataStorage();
        for(int p = startP; p <= endP; p++){
            gds.getTestData(p, x);
        }
        return gds;
    }

    private static boolean isPreciseEnough(double error){
        if(error < 0.000001)
            return true;
        else
            return false;


    }
    static void precisionTest(double start, double stop, double interval, int tries){
        ArrayList<Integer> listN = new ArrayList<>();
        ArrayList<Double> listX = new ArrayList<>();
        for (; start <= stop; start+=interval){

            GraphDataStorage graphDataStorage = Ln.createGraph(1, tries, start);
            for (GraphDataStorage.GraphIndex gi:graphDataStorage.graph) {
                if(isPreciseEnough(gi.naiveNormErr) || isPreciseEnough(gi.naiveRevErr) || isPreciseEnough(gi.smartNormErr) || isPreciseEnough(gi.smartRevErr) ){
                    listN.add(gi.numberOfTries);
                    listX.add(start);
                    break;
                }
            }

        }
        try{
            FileWriter fw=new FileWriter("C:\\Users\\Kordian\\Desktop\\algorytmy numeryczne\\Precision Data.csv");
            fw.write("x" +GraphDataStorage.SEPARATOR+ "n\n");

            for(int i = 0; i<listX.size(); i++){
                fw.write(listX.get(i) + ";" + listN.get(i) + "\n");
            }

            fw.close();
        }catch(Exception e){System.out.println(e);}
        System.out.println("Precision Data extracted...");
    }
}
