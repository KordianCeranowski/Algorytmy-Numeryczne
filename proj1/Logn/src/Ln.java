import java.util.ArrayList;

public class Ln {
    ArrayList<Double> naiveValues; //generated using taylor
    ArrayList<Double> smartValues; //generated by multiplying last value
    protected double N;
    public double x;
    public double trueLn;



    //szereg McLaurina przewiduje dokładność dla wartości -1<x<=1 dla ln=(1+x)
    // wyraz to (((-1)^(n+1))/n) * x^n

    public Ln( double x, int N ) {
        this.N = N;
        this.x = x;
        trueLn = java.lang.Math.log(x);
        naiveValues = fillArrayNaive();
        smartValues = fillArraySmart();
    }

    private ArrayList<Double> fillArrayNaive(){
        double x = this.x-1.0d;
        ArrayList<Double> naiveValues = new ArrayList<>();
        for(int n = 1; n <= N; n++){
            naiveValues.add((MyMath.powForMinusOne(n+1.0d)/n) * MyMath.power(x, n));
        }
        return naiveValues;
    }
    private ArrayList<Double> fillArraySmart(){
        double x = this.x-1;
        ArrayList<Double> smartValues = new ArrayList<>();
        double tempValue = x;
        for(double n=1; n<=N; n++){
            //różnica między kolejnymi wyrazami to -nx/(n+1)
            smartValues.add(tempValue);
            tempValue *= (-n*x/(n+1.0));
        }
        return smartValues;
    }

    public double getSum(ArrayList<Double> values){
        double sum = 0;
        for ( double value : values ) {
            sum += value;
        }
        return sum;
    }
    public double getReverseCountedSum(ArrayList<Double> values){
        double sum = 0;
        for(int i = values.size(); i>0; i--){
            sum += values.get(i-1);
        }
        return sum;
    }

    public double getRelativeError(double x){
        return (Math.abs(this.trueLn - x)/this.trueLn);
    }

}
