import java.io.FileWriter;
import java.util.ArrayList;
import java.util.Collections;


public class Ln {
    public static final String SEPARATOR = ";";

    ArrayList<Double> naiveValues; //generated using taylor
    ArrayList<Double> smartValues; //generated by multiplying last value

    ArrayList<Double> sumsNaiveNormal;
    ArrayList<Double> sumsSmartNormal;
    ArrayList<Double> sumsNaiveReversed;
    ArrayList<Double> sumsSmartReversed;

    ArrayList<Double> errNaiveNormal;
    ArrayList<Double> errSmartNormal;
    ArrayList<Double> errNaiveReversed;
    ArrayList<Double> errSmartReversed;

    protected double N;
    public double x;
    public double trueLn;

    //szereg McLaurina przewiduje dokładność dla wartości -1<x<=1 dla ln=(1+x)
    // wyraz to (((-1)^(n+1))/n) * x^n

    public Ln( double x, int N ) {
        this.N = N;
        this.x = x;
        trueLn = java.lang.Math.log(x);

        naiveValues = fillArrayNaive();
        smartValues = fillArraySmart();

        sumsNaiveNormal = fillSumsNormal(naiveValues);
        sumsSmartNormal = fillSumsNormal(smartValues);
        sumsNaiveReversed = fillSumsReversed(naiveValues);
        sumsSmartReversed = fillSumsReversed(smartValues);

        errNaiveNormal = getError(sumsNaiveNormal);
        errSmartNormal = getError(sumsSmartNormal);
        errNaiveReversed = getError(sumsNaiveReversed);
        errSmartReversed = getError(sumsSmartReversed);
    }

    private ArrayList<Double> fillArrayNaive(){
        double x = this.x-1.0d;
        ArrayList<Double> naiveValues = new ArrayList<>();
        for(int n = 1; n <= N; n++){
            naiveValues.add((MyMath.powForMinusOne(n+1.0d)/n) * MyMath.power(x, n));
        }
        return naiveValues;
    }
    private ArrayList<Double> fillArraySmart(){
        double x = this.x-1;
        ArrayList<Double> smartValues = new ArrayList<>();
        double tempValue = x;
        for(double n=1; n<=N; n++){
            //różnica między kolejnymi wyrazami to -nx/(n+1)
            smartValues.add(tempValue);
            tempValue *= (-n*x/(n+1.0));
        }
        return smartValues;
    }

    private ArrayList<Double> fillSumsNormal(ArrayList<Double> array){
        ArrayList<Double> out = new ArrayList<>();
        double tempSum = 0;
        for(double val : array){
            tempSum += val;
            out.add(tempSum);
        }
        return out;
    }
    private ArrayList<Double> fillSumsReversed(ArrayList<Double> in){
        ArrayList<Double> out = new ArrayList<>();
        double sum = 0;
        for(int i = in.size()-1; i >= 0; i--){
            sum += in.get(i);
        }
        out.add(sum);

        for(int i = 1; i < in.size(); i++){
            sum -= in.get(in.size() - i);
            out.add(sum);
        }
        Collections.reverse(out);
        return out;
    }

    private ArrayList<Double> getError(ArrayList<Double> in){
        ArrayList<Double> out = new ArrayList<>();
        for (Double val : in){
            out.add(Math.abs(this.trueLn - val));
        }
        return out;
    }

    public void packDataToCSV(){
        try{
            FileWriter fw=new FileWriter("C:\\Users\\Kordian\\Desktop\\LnData\\Wynik Ln(" + x + ").csv");
            fw.write( "n" +SEPARATOR+ "errNaiveNormal" +SEPARATOR+ "errNaiveReversed" +SEPARATOR+ "errSmartNormal" +SEPARATOR+ "errSmartReversed\n");

            for (int i = 0; i<1000000; i++) {
                fw.write((i+1 +SEPARATOR+ errNaiveNormal.get(i)+SEPARATOR+ errNaiveReversed.get(i) +SEPARATOR+ errSmartNormal.get(i).toString() +SEPARATOR+ errSmartReversed.get(i) + "\n").replace('.', ','));
                System.out.println(i);
            }

            fw.close();
        }catch(Exception e){System.out.println(e);}
        System.out.println("Direct Data extracted...");
    }




}
